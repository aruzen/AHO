# Accessorの設計パターンについて

## 謝罪

内部のVulkanを隠し、このパターン以上にコストがかからず、テンプレートを隠せるパターンを思いつきませんでした。
普通のPimplのようにimpl側に関数を書いて親から呼び出せば良かったとか, shared_ptrではなくplacement newの方が良かったかもとか(諸説あり)、
反省点は多々あります。

> 暇があったら関数をimpl側に移そうと思います

## 概要

このパターンは、C++ において内部実装を隠蔽しつつ、生成時に挙動を切り替え、アクセサクラスから統一的にデータを扱えるようにする設計手法です。

* 内部実装を Pimpl のように隠す
* `std::shared_ptr` などのハンドルクラスを通じてアクセス
* 親クラスは具体的な実装に依存せず同一インターフェースで利用可能
* テンプレートを隠せる
* 仮想関数を使わず、生成コスト・コピーコストを最小化

## 構造

```
ParentClass
└── AccessorClass (shared_ptr)
       └── ImplClass
```

* **ImplClass**: 内部実装を隠すクラス（Pimpl）、本実装ではメンバ関数を持たずデータを持たせた
* **AccessorClass**: `shared_ptr<ImplClass>` を保持し API を統一
* **ParentClass**: AccessorClass を持ち、具体実装に依存せず操作可能

## 特徴

| 特徴         | 内容                                              |
| ---------- | ----------------------------------------------- |
| 内部実装の隠蔽    | Pimpl により実装詳細を隠す                                |
| 非仮想 / 値型   | 仮想関数を使わず、コピーも安価                                 |
| 生成時の振る舞い   | Accessor や Impl のコンストラクタで初期化方法を切り替え可能           |
| 統一インターフェース | 親クラスからは Accessor を通じて共通 API を使用可能               |
| 拡張性        | Factory や DI を導入せずとも柔軟に拡張可能（生成時の条件に応じて派生クラスを作る） |

## 使用例

```cpp
// Impl.hpp
class Impl {
public:
    Impl(...) { /* 初期化 */ }
};
```

```cpp
// Impl.hppはincludeしない
struct Impl;
class Accessor {
public:
    std::shared_ptr<Impl> impl;
};

class Parent : public Accessor {
public:
    Parent(...) : impl(new Impl(...)) {}
};
```

* `Parent` は生成時の `config` によって異なる振る舞いを持つ
* 仮想関数や外部 Factory を使用せず簡潔で高速
* 内部実装の変更は `Impl` のみで済む

## 利点

* コスト効率が高い（non-virtual, コピーコストほぼゼロ）
* 内部実装の変更を親クラスや外部に影響させない
* C++ の値型・スタック型オブジェクトに最適
* 実装を抽象化できるのでテストや依存関係管理が容易

## 注意点

* 生成後に動的に挙動を切り替える必要がある場合は Factory や Strategy と組み合わせる
* 依存性注入やプラグイン機構を導入する場合は、Accessor 内の shared_ptr を使った登録型 Factory と併用可能

## まとめ

このパターンは、

* Pimpl による実装隠蔽
* shared_ptr を通じた抽象化アクセス
* 生成時のみ異なる振る舞いの導入

を組み合わせることで、**C++ において軽量かつ柔軟な設計**を実現する方法です。
